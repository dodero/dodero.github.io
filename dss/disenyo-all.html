<!DOCTYPE html>
<html>
<head>
<title>disenyo-all.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="dise%C3%B1o-de-sistemas-software">DISEÑO DE SISTEMAS SOFTWARE</h1>
<h2 id="bloques">Bloques</h2>
<ol>
<li>Principios de diseño OO</li>
<li>Patrones de diseño</li>
<li>Arquitectura de software</li>
</ol>
<p><a id="clase01"></a></p>
<h2 id="span-stylecolorblueintroducci%C3%B3nspan"><span style="color:blue;">Introducción</span></h2>
<h3 id="problem%C3%A1ticas">Problemáticas</h3>
<ul>
<li>Variabilidad</li>
<li>Acoplamiento</li>
<li>Complejidad</li>
<li>Robustez</li>
<li>Reutilización</li>
<li>Flexibilidad</li>
</ul>
<h3 id="principios">Principios</h3>
<ul>
<li>Ocultación: OCP, ISP, LSP</li>
<li>Cohesión: SRP</li>
<li>Ortogonalidad: ISP</li>
<li>Delegación</li>
</ul>
<h3 id="t%C3%A9cnicas">Técnicas</h3>
<ul>
<li>Refactoring</li>
<li>Bibliotecas y frameworks</li>
<li>Contratos</li>
<li>Inyección de dependencias</li>
<li>Patrones</li>
</ul>
<h3 id="paradigmas">Paradigmas</h3>
<ul>
<li>Estructurado (E. W. Dijsktra)</li>
<li>Objetos (O. J. Dahl &amp; K. Nygaard)</li>
<li>Funcional (J. McCarthy)</li>
<li>Aspectos (G. Kiczales)</li>
<li>Eventos</li>
</ul>
<h4 id="pregunta">Pregunta</h4>
<p><span style="color:red;"><em>¿De qué fecha data cada paradigma?</em>
<em>¿Cuál diríais que es el más antiguo?</em></span></p>
<h4 id="respuesta">Respuesta</h4>
<p><em>¿De qué fecha data cada paradigma?</em></p>
<ul>
<li>Estructurado (E. W. Dijsktra, 1968)</li>
<li>Objetos (O. J. Dahl &amp; K. Nygaard, 1966)</li>
<li>Funcional (J. McCarthy, 1958)</li>
<li>Aspectos (G. Kiczales, 1997)</li>
<li>Eventos</li>
</ul>
<h2 id="span-stylecolorbluecasos-pr%C3%A1cticosspan"><span style="color:blue;">Casos prácticos</span></h2>
<ol>
<li><a href="#handler">Identificadores</a></li>
<li><a href="#junit">Framework de pruebas unitarias</a></li>
<li><a href="#knights">Caballeros de la mesa redonda</a></li>
<li><a href="#guitarras">Guitarras Paco</a></li>
<li><a href="#figuras">Figuras geométricas</a></li>
</ol>
<h1 id="caso-pr%C3%A1ctico-1">CASO PRÁCTICO 1</h1>
<p><a id="handler"></a></p>
<h2 id="identificadores">Identificadores</h2>
<h3 id="versi%C3%B3n-inicial-identificadores-v01">Versión inicial: Identificadores v0.1</h3>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empleado</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> dni;
    Empleado (String dni) <span class="hljs-keyword">throws</span> NumberFormatException {
      <span class="hljs-keyword">this</span>.dni = <span class="hljs-keyword">new</span> Integer(dni).intValue();
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDni</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> dni;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(dni).toString();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Empleado otro)</span> </span>{
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dni - otro.getDni();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Empleado otro)</span> </span>{
       <span class="hljs-keyword">return</span> dni==otro.getDni();
    }
  }
</div></code></pre>
<h4 id="cr%C3%ADticas">Críticas:</h4>
<ul>
<li><strong>Flexibilidad</strong>: El Real Decreto 338/1990 regula el uso de NIFs en lugar de DNIs. ¡Hay que cambiar toda la implementación!</li>
</ul>
<h3 id="implementaci%C3%B3n-alternativa-identificadores-v02">Implementación alternativa: Identificadores v0.2</h3>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empleado</span> </span>{
    <span class="hljs-keyword">private</span> String nif;
    Empleado (String nif) {
      <span class="hljs-keyword">this</span>.nif = nif
    }
    <span class="hljs-function">String <span class="hljs-title">getNif</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> id; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> nif; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Empleado otro)</span> </span>{
       <span class="hljs-keyword">return</span> nif.compareTo(otro.getNif());
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Empleado otro)</span> </span>{
       <span class="hljs-keyword">return</span> nif.equals(otro.getId());
    }
  }
</div></code></pre>
<h4 id="cr%C3%ADticas">Críticas:</h4>
<ul>
<li><strong>Reutilización</strong>: Posiblemente haya más situaciones (algunas futuras) donde hagan falta <em>identificadores</em> que incluso pueden cambiar. Por ejemplo: números de la seguridad social, tarjetas de identidad, números de cuenta corriente, IBAN, etc.</li>
</ul>
<h3 id="hacemos-refactoring-patr%C3%B3n-handler">Hacemos refactoring: patrón <em>handler</em></h3>
<ul>
<li>
<p>Manejo de <em>identificadores</em> de forma independiente de la
implementación del objeto identificado.</p>
</li>
<li>
<p>Cambio fácil de implementación de los identificadores (<code>int</code>,
<code>String</code>, etc.) hacia cualquier tipo básico o clase primitiva,
sencilla o compuesta.</p>
</li>
</ul>
<h2 id="span-stylecolorbluepatr%C3%B3n-handlerspan"><span style="color:blue;">Patrón Handler</span></h2>
<p><img src="./figuras/handler.png" alt="Diseño de un handler"></p>
<ul>
<li>
<p><strong>Identifiable</strong>: Clase cliente que necesita identificar a sus objetos a través de algún atributo identificador</p>
</li>
<li>
<p><strong>Handler</strong>: Interfaz para declarar los identificadores de los objetos de la clase <code>Identifiable</code></p>
</li>
<li>
<p><strong>ConcreteHandler</strong>: Implementación concreta de la interfaz <code>Handler</code></p>
</li>
</ul>
<h4 id="implementaci%C3%B3n-del-patr%C3%B3n">Implementación del patrón</h4>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Handler</span></span>{
      <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Handler otro)</span></span>;
  }
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdentificadorNumerico</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handler</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    IdentificadorNumerico (String id) <span class="hljs-keyword">throws</span> NumberFormatException {
      <span class="hljs-keyword">this</span>.id = <span class="hljs-keyword">new</span> Integer(id).intValue();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(id).toString();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Handler otro)</span> </span>{
      <span class="hljs-keyword">return</span> toString().compareTo(otro.toString());
    }
  }
</div></code></pre>
<h3 id="ejemplo-identificadores-en-java-%E2%80%93-javalangcomparable">Ejemplo: Identificadores en Java – <code>java.lang.Comparable</code></h3>
<p>Implementar un identificador utilizando <code>java.lang.Comparable</code> del JDK.</p>
<p><code>Comparable</code> es una interfaz implementada por <code>String</code>, <code>File</code>, <code>Date</code>, etc. y todas las llamadas <em>clases de envoltura</em> del JDK (i.e. <code>Integer</code>, <code>Long</code>, etc.)</p>
<p><strong>Métodos de la interfaz</strong>:</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> ClassCastException
</span></div></code></pre>
<p><strong>Invariantes:</strong></p>
<p><code>sgn(x.compareTo(y)) = -sgn(y.compareTo(x))</code></p>
<p><code>(x.compareTo(y)&gt;0 and y.compareTo(z)&gt;0)</code> $\Rightarrow$ <code>x.compareTo(z)&gt;0</code></p>
<p><code>x.compareTo(y)=0</code> $\Rightarrow$ <code>sgn(x.compareTo(z))=sgn(y.compareTo(z))</code> $\forall$ <code>z</code></p>
<p><strong>Consistencia con <code>equals</code></strong>:</p>
<p><code>(x.compareTo(y)=0)</code> $\Leftrightarrow$ <code>(x.equals(y))</code></p>
<h2 id="span-stylecolorbluereutilizaci%C3%B3n-y-flexibilidadspan"><span style="color:blue;">Reutilización y flexibilidad</span></h2>
<ul>
<li><strong>Flexibilidad</strong>: Adaptarse a cambios de requisitos y construir software fácil de cambiar</li>
<li><strong>Reutilización</strong>: Construir software fácil de reutilizar sin tener que cambiar los módulos ya escritos</li>
</ul>
<h1 id="caso-pr%C3%A1ctico-2">CASO PRÁCTICO 2</h1>
<p><a id="junit"></a></p>
<h2 id="framework-de-pruebas-unitarias">Framework de pruebas unitarias</h2>
<ul>
<li>JUnit es un framework en Java que sirve para diseñar, construir y ejecutar <strong>pruebas unitarias</strong></li>
<li>Una prueba unitaria comprueba la corrección de un <em>módulo</em> de software en cuanto a funcionalidades que ofrece.</li>
<li>En el caso de Java, las pruebas unitarias comprueban la corrección de cada uno de los métodos de <em>cada clase</em>.</li>
</ul>
<p><span style="color:red;">¿Cómo funciona?</span></p>
<h3 id="%C2%BFc%C3%B3mo-probar-saludojava">¿Cómo probar <code>Saludo.java</code>?</h3>
<p>Incluir un método <code>main</code> que pruebe la funcionalidad de la clase:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Saludo</span> </span>{
  <span class="hljs-comment">/**
  * Imprime "Hola Mundo!"
  */</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saludar</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"Hola Mundo!"</span>);
  }
  <span class="hljs-comment">/**
  * Imprime un mensaje
  */</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saludar</span><span class="hljs-params">(String mensaje)</span> </span>{
    System.out.println(mensaje);
  }

  <span class="hljs-comment">/**
  * Tests
  */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> </span>{
    Saludo saludo1 = <span class="hljs-keyword">new</span> Saludo();
    saludo1.saludar();

    Saludo saludo2 = <span class="hljs-keyword">new</span> Saludo(<span class="hljs-string">"Hola caracola!"</span>);
    saludo2.saludar();
  }
}
</div></code></pre>
<h3 id="pegas">Pegas</h3>
<ul>
<li>
<p>Cuanto más grande sea la interfaz de la clase, mayor será el main</p>
</li>
<li>
<p>El tamaño del código de la clase crece por las pruebas</p>
</li>
<li>
<p>Poco fiable, porque main forma parte de la misma clase y tiene acceso a los elementos privados</p>
</li>
<li>
<p>Difícil de automatizar las pruebas, incluso pasando argumentos a <code>main</code></p>
</li>
</ul>
<h3 id="ejemplo-software-cliente-del-framework">Ejemplo: software <em>cliente</em> del framework</h3>
<h4 id="caso-de-prueba-con-junit-4">Caso de prueba con jUnit 4</h4>
<pre class="hljs"><code><div>  <span class="hljs-keyword">import</span> org.junit.*;
  <span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;

  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaludoTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{
      junit.textui.TestRunner.run(SaludoTest.class);
    }
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saludar</span><span class="hljs-params">()</span> </span>{
      Saludo hola = <span class="hljs-keyword">new</span> Saludo();
      <span class="hljs-keyword">assert</span>( hola!=<span class="hljs-keyword">null</span> );
      assertEquals(<span class="hljs-string">"Hola Mundo!"</span>, hola.saludar() );
    }
  }
</div></code></pre>
<p>Ejecución de los tests:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.runner.JUnitCore;
<span class="hljs-keyword">import</span> org.junit.runner.Result;
<span class="hljs-keyword">import</span> org.junit.runner.notification.Failure;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestRunner</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    Result result = JUnitCore.runClasses(SaludoTest.class);
    <span class="hljs-keyword">for</span> (Failure failure : result.getFailures()) {
      System.out.println(failure.toString());
    }
  }
}
</div></code></pre>
<p>¿De qué están hechas las anotaciones como <code>@Test</code>?
Veamos una versión anterior de jUnit, que expone más claramente las <em>tripas</em> del framework</p>
<h4 id="caso-de-prueba-con-junit-3">Caso de prueba con jUnit 3</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> junit.framework.TestCase;
<span class="hljs-keyword">import</span> junit.framework.Assert;
  
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaludoTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SaludoTest</span><span class="hljs-params">(String nombre)</span> </span>{
      <span class="hljs-keyword">super</span>(nombre);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSaludar</span><span class="hljs-params">()</span> </span>{
      Saludo hola = <span class="hljs-keyword">new</span> Saludo();
      <span class="hljs-keyword">assert</span>( hola!=<span class="hljs-keyword">null</span> );
      assertEquals(<span class="hljs-string">"Hola Mundo!"</span>, hola.saludar() );
    }
}
</div></code></pre>
<p><a id="clase02"></a></p>
<h3 id="dise%C3%B1o-del-framework-junit">Diseño del framework jUnit</h3>
<h4 id="estructura-de-clases">Estructura de clases:</h4>
<p><img src="./figuras/junit-design-1.png" alt="Clases del framework jUnit"></p>
<h4 id="ejecuci%C3%B3n-de-casos-de-prueba">Ejecución de casos de prueba:</h4>
<p><img src="./figuras/junit-design-2.png" alt="Clases del framework jUnit"></p>
<h3 id="ejemplo-aplicaci%C3%B3n-de-comercio-electr%C3%B3nico">Ejemplo: aplicación de comercio electrónico</h3>
<p>Diseño de una aplicación de comercio electrónico:</p>
<ul>
<li><code>ShoppingCart</code> - carrito de la compra</li>
<li><code>CreditCard</code> - tarjeta de crédito</li>
<li><code>Product</code>- artículos</li>
<li>Etc.</li>
</ul>
<p>Diseño de pruebas unitarias de <code>ShoppingCart</code> para:</p>
<ul>
<li>Probar carrito de la compra (añadir/eliminar artículos)</li>
<li>Probar validación de tarjetas de crédito</li>
<li>Probar manejo de varias monedas</li>
<li>Etc.</li>
</ul>
<h4 id="shoppingcart">ShoppingCart</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCart</span> </span>{
  <span class="hljs-keyword">private</span> ArrayList items;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShoppingCart</span><span class="hljs-params">()</span> </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(Product p)</span> </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeItem</span><span class="hljs-params">(Product p)</span>
      <span class="hljs-keyword">throws</span> ProductNotFoundException </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{ ... }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>{ ... }
}
</div></code></pre>
<h4 id="shoppingcarttestcase-con-junit-3">ShoppingCartTestCase con jUnit 3</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> junit.framework.TestCase;
<span class="hljs-keyword">import</span> junit.framework.TestSuite;
<span class="hljs-keyword">import</span> junit.framework.Assert;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCartTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span> </span>{
  <span class="hljs-keyword">private</span> ShoppingCart bookCart;
  <span class="hljs-keyword">private</span> Product defaultBook;
  <span class="hljs-comment">//...</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
      bookCart = <span class="hljs-keyword">new</span> ShoppingCart();
      defaultBook = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Extreme Programming"</span>, <span class="hljs-number">23.95</span>);
      bookCart.addItem(defaultBook);
  }
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> </span>{
      bookCart = <span class="hljs-keyword">null</span>;
  }  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEmpty</span><span class="hljs-params">()</span> </span>{
      bookCart.empty();
      assertTrue(bookCart.isEmpty());
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductAdd</span><span class="hljs-params">()</span> </span>{
      Product book = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Refactoring"</span>, <span class="hljs-number">53.95</span>);
      bookCart.addItem(book);
      <span class="hljs-keyword">double</span> expectedBalance = defaultBook.getPrice() + book.getPrice();
      assertEquals(expectedBalance, bookCart.getBalance(), <span class="hljs-number">0.0</span>);
      assertEquals(<span class="hljs-number">2</span>, bookCart.getItemCount());
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductRemove</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ProductNotFoundException </span>{
      bookCart.removeItem(defaultBook);
      assertEquals(<span class="hljs-number">0</span>, bookCart.getItemCount());
      assertEquals(<span class="hljs-number">0.0</span>, bookCart.getBalance(), <span class="hljs-number">0.0</span>);
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductNotFound</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">try</span> {
          Product book = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Ender's Game"</span>, <span class="hljs-number">4.95</span>);
          bookCart.removeItem(book);
          fail(<span class="hljs-string">"Should raise a ProductNotFoundException"</span>);
      } <span class="hljs-keyword">catch</span>(ProductNotFoundException success) {
          ...
      }
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">suite</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">// Use reflection to add all testXXX() methods</span>
         TestSuite suite = <span class="hljs-keyword">new</span> TestSuite(ShoppingCartTest.class);
      <span class="hljs-comment">// Alternatively, but prone to error when adding more</span>
      <span class="hljs-comment">// test case methods...</span>
      <span class="hljs-comment">// TestSuite suite = new TestSuite();</span>
      <span class="hljs-comment">// suite.addTest(new ShoppingCartTest("testProductAdd"));</span>
      <span class="hljs-comment">// suite.addTest(new ShoppingCartTest("testEmpty"));</span>
      <span class="hljs-comment">// suite.addTest(new ShoppingCartTest("testProductRemove"));</span>
      <span class="hljs-comment">// suite.addTest(new ShoppingCartTestCase("testProductNotFound"));</span>
         <span class="hljs-keyword">return</span> suite;
  }
}
</div></code></pre>
<p>Ahora agrupamos varios casos de prueba en una misma <em>suite</em>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> junit.framework.Test;
<span class="hljs-keyword">import</span> junit.framework.TestSuite;
<span class="hljs-keyword">import</span> org.junit.runner.JUnitCore;
<span class="hljs-keyword">import</span> org.junit.runner.Result;
<span class="hljs-keyword">import</span> org.junit.runner.notification.Failure;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EcommerceTestSuite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestSuite</span> </span>{
    <span class="hljs-comment">//...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">suite</span><span class="hljs-params">()</span> </span>{
        TestSuite suite = <span class="hljs-keyword">new</span> TestSuite();
        suite.addTest(ShoppingCartTest.suite());
        <span class="hljs-keyword">return</span> suite;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestRunner</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    Result result = JUnitCore.runClasses(EcommerceTestSuite.class);
    <span class="hljs-keyword">for</span> (Failure failure : result.getFailures()) {
      System.out.println(failure.toString());
    }
  }
}
</div></code></pre>
<h4 id="shoppingcarttestcase-con-junit-4">ShoppingCartTestCase con jUnit 4</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.fail;

<span class="hljs-keyword">import</span> org.junit.After;
<span class="hljs-keyword">import</span> org.junit.Before;
<span class="hljs-keyword">import</span> org.junit.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCartTest</span> </span>{
  <span class="hljs-keyword">private</span> ShoppingCart bookCart;
  <span class="hljs-keyword">private</span> Product defaultBook;
  <span class="hljs-comment">//...</span>
  <span class="hljs-meta">@Before</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
      bookCart = <span class="hljs-keyword">new</span> ShoppingCart();
      defaultBook = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Extreme Programming"</span>, <span class="hljs-number">23.95</span>);
      bookCart.addItem(defaultBook);
  }
  <span class="hljs-meta">@After</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> </span>{
      bookCart = <span class="hljs-keyword">null</span>;
  }
  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEmpty</span><span class="hljs-params">()</span> </span>{
      bookCart.empty();
      assertTrue(bookCart.isEmpty());
  }
  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductAdd</span><span class="hljs-params">()</span> </span>{
      Product book = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Refactoring"</span>, <span class="hljs-number">53.95</span>);
      bookCart.addItem(book);
      <span class="hljs-keyword">double</span> expectedBalance = defaultBook.getPrice() + book.getPrice();
      assertEquals(expectedBalance, bookCart.getBalance(), <span class="hljs-number">0.0</span>);
      assertEquals(<span class="hljs-number">2</span>, bookCart.getItemCount());
  }
  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductRemove</span><span class="hljs-params">()</span> </span>{
      bookCart.removeItem(defaultBook);
      assertEquals(<span class="hljs-number">0</span>, bookCart.getItemCount());
      assertEquals(<span class="hljs-number">0.0</span>, bookCart.getBalance(), <span class="hljs-number">0.0</span>);
  }
  <span class="hljs-meta">@Test</span>(expected = ProductNotFoundException.class)
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProductNotFound</span><span class="hljs-params">()</span> </span>{
      Product book = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">"Ender's Game"</span>, <span class="hljs-number">4.95</span>);
      bookCart.removeItem(book);
      fail(<span class="hljs-string">"Should raise a ProductNotFoundException"</span>);
  }
}
</div></code></pre>
<h4 id="ecommercetestsuite-con-junit-3">EcommerceTestSuite con jUnit 3</h4>
<pre class="hljs"><code><div>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EcommerceTestSuite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestSuite</span> </span>{
      <span class="hljs-comment">//...</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">suite</span><span class="hljs-params">()</span> </span>{
          TestSuite suite = <span class="hljs-keyword">new</span> TestSuite();
          suite.addTest(ShoppingCartTest.suite());
          suite.addTest(CreditCardTest.suite());
          <span class="hljs-comment">// etc.</span>
          <span class="hljs-keyword">return</span> suite;
      }
  }
</div></code></pre>
<h4 id="ecommercetestsuite-con-junit-4">EcommerceTestSuite con jUnit 4</h4>
<pre class="hljs"><code><div>  <span class="hljs-meta">@RunWith</span>(Suite.class)
  <span class="hljs-meta">@SuiteClasses</span>({ ShoppingCartTest.class,
                  CreditCardTest.class })
  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EcommerceTestSuite</span> </span>{
      <span class="hljs-comment">//...</span>
  }
</div></code></pre>
<h3 id="span-stylecolorredejercicio-creditcardtestspan"><span style="color:red;">Ejercicio: CreditCardTest</span></h3>
<p>Diseñar y codificar una suite de casos de prueba unitaria para <code>CreditCard</code> usando jUnit 4.</p>
<h3 id="arquitectura-del-framework">Arquitectura del framework</h3>
<p><img src="./figuras/junit-patterns.png" alt="Clases del framework jUnit"></p>
<p>En la arquitectura del framework se observan diversos patrones: Composite, Command, Adapter, Factory, Decorator, etc.</p>
<h2 id="span-stylecolorbluebibliotecas-y-frameworksspan"><span style="color:blue;">Bibliotecas y frameworks</span></h2>
<h3 id="biblioteca">Biblioteca</h3>
<p><img src="./figuras/biblioteca.png" alt="Flujo de control en una biblioteca"></p>
<h4 id="flujo-de-control-en-un-framework">Flujo de control en un framework</h4>
<p><img src="./figuras/framework.png" alt="Flujo de control en una framework"></p>
<h3 id="span-stylecolorblueframeworksspan"><span style="color:blue;">Frameworks</span></h3>
<h4 id="definici%C3%B3n-de-framework">Definición de <em>framework</em></h4>
<blockquote>
<p>Colección de clases e interfaces que cooperan para formar un diseño reutilizable de un tipo específico de software</p>
<p>–– <cite><a href="bibliografia.html#gamma">E. Gamma et al.</a></cite></p>
</blockquote>
<ul>
<li>El framework proporciona unas guías arquitectónicas (diseño empaquetado) para dividir el diseño en clases abstractas y definir sus <em>responsabilidades</em> y <em>colaboraciones</em>.</li>
<li>El framework se debe personalizar definiendo subclases y combinando instancias, o bien configurando valores que definen el comportamiento por defecto</li>
</ul>
<h4 id="principios-de-dise%C3%B1o">Principios de diseño</h4>
<ul>
<li>Datos encapsulados</li>
<li>Interfaces y clases abstractas</li>
<li>Métodos polimórficos</li>
<li>Delegación</li>
</ul>
<h4 id="herramientas-de-dise%C3%B1o">Herramientas de diseño</h4>
<ul>
<li><strong>Patrones</strong>: elementos reutilizables de diseño</li>
<li><strong>Frameworks</strong>: colecciones de patrones abstractos a aplicar</li>
</ul>
<h4 id="framework-vs-biblioteca">Framework vs. biblioteca</h4>
<ul>
<li>API orientado a objetos</li>
<li>Flujo de control invertido</li>
<li>Programador cliente (código específico) vs. programador de bibliotecas (código reutilizable)</li>
</ul>
<h3 id="principios-y-t%C3%A9cnicas-de-un-framework">Principios y técnicas de un framework</h3>
<ul>
<li>
<p><strong>Abstracción</strong></p>
<ul>
<li>Clases y componentes abstractos</li>
<li>Interfaces abiertas</li>
<li>Uso de patrones de diseño</li>
<li>Componentes de un dominio específico</li>
</ul>
</li>
<li>
<p>Máxima <strong>cohesión</strong>, mínimo <strong>acoplamiento</strong></p>
<ul>
<li>Minimizar dependencias: Una clase presenta una dependencia con otra clase si la primera usa una instancia de la segunda.</li>
<li>Cuando no se pueden eliminar las dependencias, mantener las abstractas e <em>inyectar</em> las concretas.</li>
</ul>
</li>
<li>
<p><strong>Inyección de dependencias</strong>: una clase o módulo no debería configurar sus dependencias estáticamente, sino ser configurada desde fuera</p>
</li>
</ul>
<h1 id="caso-pr%C3%A1ctico-3">CASO PRÁCTICO 3</h1>
<p><a id="knights"></a></p>
<h2 id="ejemplo-caballeros-de-la-mesa-redonda">Ejemplo: Caballeros de la mesa redonda</h2>
<p><strong>Tomado de <a href="bibliografia.html#spring">Spring in Action</a></strong></p>
<p>Añadir pruebas unitarias a la solución siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnightOfTheRoundTable</span> </span>{
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> HolyGrailQuest quest;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KnightOfTheRoundTable</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">this</span>.name = name;
    quest = <span class="hljs-keyword">new</span> HolyGrailQuest();
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> HolyGrail <span class="hljs-title">embarkOnQuest</span><span class="hljs-params">()</span>
      <span class="hljs-keyword">throws</span> GrailNotFoundException </span>{
    <span class="hljs-keyword">return</span> quest.embark();
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolyGrailQuest</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HolyGrailQuest</span><span class="hljs-params">()</span> </span>{}
  <span class="hljs-function"><span class="hljs-keyword">public</span> HolyGrail <span class="hljs-title">embark</span><span class="hljs-params">()</span>
          <span class="hljs-keyword">throws</span> GrailNotFoundException </span>{
  HolyGrail grail = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// Look for grail</span>
    ...
    <span class="hljs-keyword">return</span> grail;
  }
}
</div></code></pre>
<h3 id="dise%C3%B1o-de-pruebas-con-junit-3">Diseño de pruebas con jUnit 3</h3>
<p><span style="color:red;">¿Dónde está el acoplamiento?</span></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> junit.framework.TestCase;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnightOfTheRoundTableTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEmbarkOnQuest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> GrailNotFoundException </span>{
    KnightOfTheRoundTable knight =
        <span class="hljs-keyword">new</span> KnightOfTheRoundTable(<span class="hljs-string">"CruzadoMagico"</span>);
    HolyGrail grail = knight.embarkOnQuest();
    assertNotNull(grail);
    assertTrue(grail.isHoly());
  }
}
</div></code></pre>
<ul>
<li>
<p>Instanciación de <code>HolyGrail</code></p>
</li>
<li>
<p>Cada vez que se prueba <code>KnightOfTheRoundTable</code>, también se prueba <code>HolyGrailQuest</code>.</p>
</li>
<li>
<p>No se puede pedir a <code>HolyGrailQuest</code> que se comporte de otra forma (v.g. devolver null o elevar una excepción)</p>
</li>
</ul>
<p>Ocultar la implementación detrás de una interfaz:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Knight</span> </span>{
  <span class="hljs-function">Object <span class="hljs-title">embarkOnQuest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> QuestFailedException</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnightOfTheRoundTable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Knight</span> </span>{
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> Quest quest;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KnightOfTheRoundTable</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">this</span>.name = name;
    quest = <span class="hljs-keyword">new</span> HolyGrailQuest();
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">embarkOnQuest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> QuestFailedException </span>{
    <span class="hljs-keyword">return</span> quest.embark();
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quest</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">abstract</span> Object <span class="hljs-title">embark</span><span class="hljs-params">()</span>
    <span class="hljs-keyword">throws</span> QuestFailedException</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolyGrailQuest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quest</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HolyGrailQuest</span><span class="hljs-params">()</span> </span>{}
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">embark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> QuestFailedException </span>{
    <span class="hljs-comment">// Do whatever it means to embark on a quest</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HolyGrail();
  }
}
</div></code></pre>
<ul>
<li>El <code>Knight</code> aún recibe un tipo específico de <code>Quest</code></li>
<li><span style="color:red;">¿Debe ser el caballero responsable de obtener un desafío?</span></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KnightOfTheRoundTable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Knight</span> </span>{
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> Quest quest;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KnightOfTheRoundTable</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">this</span>.name = name;
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">embarkOnQuest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> QuestFailedException </span>{
    <span class="hljs-keyword">return</span> quest.embark();
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setQuest</span><span class="hljs-params">(Quest quest)</span> </span>{
    <span class="hljs-keyword">this</span>.quest = quest;
  }
}
</div></code></pre>
<ul>
<li>
<p>El caballero sólo sabe del desafío a través de su interfaz <code>Quest</code>.</p>
</li>
<li>
<p>Puede asignársele cualquier implementación de <code>Quest</code>
(<code>HolyGrailQuest</code>, <code>RescueDamselQuest</code>, etc.)</p>
</li>
</ul>
<p><img src="./figuras/di-knight.png" alt=""></p>
<h2 id="span-stylecolorblueinyecci%C3%B3n-de-dependenciasspan"><span style="color:blue;">Inyección de dependencias</span></h2>
<p><img src="./figuras/dep-injection.png" alt=""></p>
<h3 id="inversi%C3%B3n-de-control">Inversión de control</h3>
<ul>
<li>Es la base de la inyección de dependencias</li>
</ul>
<blockquote>
<p>The question is: <em>what aspect of control are they inverting?</em> [...] Early <strong>user interfaces</strong> were controlled by the application program. You would have a sequence of commands like &quot;Enter name&quot;, &quot;enter address&quot;; your program would drive the prompts and pick up a response to each one. With <strong>graphical</strong> (or even screen based) UIs the UI framework would contain this main loop and your program instead provided event handlers for the various fields on the screen. The main control of the program was inverted, moved away from you to the framework.</p>
<p><cite> Martin Fowler, <a href="http://martinfowler.com/articles/injection.html">IoC containers and the DI pattern</a> [1]</cite></p>
</blockquote>
<p>[1] http://martinfowler.com/articles/injection.html</p>
<h4 id="ioc%E2%80%93inversion-of-control-di%E2%80%93dependency-injection">IoC–Inversion of Control / DI–Dependency Injection</h4>
<ul>
<li>Una aplicación está compuesta por dos o más clases que colaboran.</li>
<li>Los objetos deben recibir las dependencias en su creación, por parte de una entidad externa o <strong>contenedor</strong> que los coordina.</li>
<li>Inversión de la responsabilidad de cómo un objeto obtiene referencias a los objetos con los que colabora</li>
<li>Ventaja = <strong>bajo acoplamiento</strong>: un objeto sólo sabe de sus dependencias por su interfaz, no por su implementación, ni por cómo fueron instanciados.</li>
<li>Entonces la dependencia puede cambiarse por una implementación distinta (incluso en <strong>tiempo de ejecución</strong>)</li>
<li><em>Hollywood Principle: Don't call us, we'll call you&quot;.</em></li>
</ul>
<h3 id="factor%C3%ADas">Factorías</h3>
<p>Una factoría proporciona un mecanismo de inyección de dependencias, visto desde el lado opuesto (los clientes adquieren las dependencias, no se les inyecta)</p>
<p>Ejemplo: <a href="http://www.baeldung.com/spring-factorybean">Spring FactoryBean</a></p>
<h2 id="span-stylecolorbluediscusi%C3%B3n-sobre-la-reutilizaci%C3%B3nspan"><span style="color:blue;">Discusión sobre la reutilización</span></h2>
<blockquote>
<p>We most likely would have been better off not attempting to create a reusable function in the first place</p>
<p>-- <cite>Roger Sessions, <a href="http://simplearchitectures.blogspot.com.es/2012/07/misuse-of-reuse.html">The Misuse of Reuse</a> [2]</cite></p>
</blockquote>
<p>[2] http://simplearchitectures.blogspot.com.es/2012/07/misuse-of-reuse.html</p>
<h3 id="factorizar-una-funci%C3%B3n">Factorizar una función</h3>
<p><img src="./figuras/misuse-reuse-1.png" alt="Reutilización de una función"></p>
<p><img src="./figuras/misuse-reuse-2.png" alt="Reutilización de una función"></p>
<h3 id="ventajas-supuestas-de-reutilizar">Ventajas (supuestas) de reutilizar:</h3>
<p><strong>Ahorro</strong>:</p>
<p>Si $\exists s$ sistemas $\wedge ~ coste(Function~1) = c$ € $\Rightarrow$ ahorro = $c \times (s-1)$ €</p>
<h3 id="amenazas-reales">Amenazas (reales):</h3>
<p><img src="./figuras/misuse-reuse-3.png" alt="Reutilización de una función"></p>
<ul>
<li>Realmente el ahorro depende de la <strong>complejidad</strong>. Y muchas veces, la complejidad de la función está exponencialmente relacionada con el número de sistemas.</li>
<li>Con un único punto de fallo, Si la función 1 falla, todos los sistemas pueden fallar a la vez.</li>
<li>La seguridad es inversamente proporcional a la complejidad del sistema.</li>
<li>Se incrementan los costes de llevar los sistemas a la nube.</li>
</ul>
<h3 id="conclusi%C3%B3n">Conclusión</h3>
<p>No crear funciones reutilizables en primer lugar</p>
<p>Aplicar el principio <strong>YAGNI</strong>: <strong>You Ain't Gonna Need It</strong></p>
<h1 id="caso-pr%C3%A1ctico-4">CASO PRÁCTICO 4</h1>
<p><a id="guitarras"></a></p>
<h2 id="guitarras-paco">Guitarras Paco</h2>
<p>El cliente (Paco) quiere:</p>
<ul>
<li>
<p>Mantener un inventario de guitarras</p>
</li>
<li>
<p>Encontrar guitarras para sus clientes</p>
</li>
</ul>
<p>Problemas de la aplicación heredada:</p>
<ul>
<li>
<p>Caso de uso: un cliente busca una guitarra flamenca ‘Valeriano Bernal’, pero no encuentra ninguna</p>
</li>
<li>
<p>¿Problemas?</p>
</li>
</ul>
<h3 id="una-aplicaci%C3%B3n-heredada">Una aplicación heredada</h3>
<p><img src="./figuras/guitar_m1b.png" alt="Guitar e Inventory"></p>
<p><img src="./figuras/uml_guitar_m1.png" alt="Guitar"></p>
<p><img src="./figuras/uml_inventory_m1.png" alt="Inventory"></p>
<h3 id="implementaci%C3%B3n-guitarra">Implementación: Guitarra</h3>
<pre class="hljs"><code><div>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guitar</span> </span>{
     <span class="hljs-keyword">private</span> String serialNumber, builder, model, type, backWood, topWood;
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Guitar</span><span class="hljs-params">(String serialNumber, <span class="hljs-keyword">double</span> price,
                        String builder, String model, String type,
                        String backWood, String topWood)</span> </span>{
        <span class="hljs-keyword">this</span>.serialNumber = serialNumber;
        <span class="hljs-keyword">this</span>.price = price;
        <span class="hljs-keyword">this</span>.builder = builder;
        <span class="hljs-keyword">this</span>.model = model;
        <span class="hljs-keyword">this</span>.type = type;
        <span class="hljs-keyword">this</span>.backWood = backWood;
        <span class="hljs-keyword">this</span>.topWood = topWood;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSerialNumber</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> serialNumber;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> price;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">float</span> newPrice)</span> </span>{
        <span class="hljs-keyword">this</span>.price = newPrice;
     }
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBuilder</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> builder;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getModel</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> model;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> type;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBackWood</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> backWood;}
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTopWood</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> topWood;}
  }
</div></code></pre>
<h3 id="implementaci%C3%B3n-inventario">Implementación: Inventario</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inventory</span> </span>{
  <span class="hljs-keyword">private</span> List guitars;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inventory</span><span class="hljs-params">()</span> </span>{ guitars = <span class="hljs-keyword">new</span> LinkedList(); }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addGuitar</span><span class="hljs-params">(String serialNumber, <span class="hljs-keyword">double</span> price,
                        String builder, String model,
                        String type, String backWood, String topWood)</span> </span>{
    Guitar guitar = <span class="hljs-keyword">new</span> Guitar(serialNumber, price, builder,
                               model, type, backWood, topWood);
    guitars.add(guitar);
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> Guitar <span class="hljs-title">getGuitar</span><span class="hljs-params">(String serialNumber)</span> </span>{
    <span class="hljs-keyword">for</span> (Iterator i = guitars.iterator(); i.hasNext(); ) {
      Guitar guitar = (Guitar)i.next();
      <span class="hljs-keyword">if</span> (guitar.getSerialNumber().equals(serialNumber)) {
        <span class="hljs-keyword">return</span> guitar;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> Guitar <span class="hljs-title">search</span><span class="hljs-params">(Guitar searchGuitar)</span> </span>{
    <span class="hljs-keyword">for</span> (Iterator i = guitars.iterator(); i.hasNext(); ) {
      Guitar guitar = (Guitar)i.next();
      String builder = searchGuitar.getBuilder().toLowerCase();
      <span class="hljs-keyword">if</span> ((builder != <span class="hljs-keyword">null</span>) &amp;&amp; (!builder.equals(<span class="hljs-string">""</span>)) &amp;&amp;
          (!builder.equals(guitar.getBuilder().toLowerCase())))
        <span class="hljs-keyword">continue</span>;
      String model = searchGuitar.getModel().toLowerCase();
      <span class="hljs-keyword">if</span> ((model != <span class="hljs-keyword">null</span>) &amp;&amp; (!model.equals(<span class="hljs-string">""</span>)) &amp;&amp;
          (!model.equals(guitar.getModel().toLowerCase())))
        <span class="hljs-keyword">continue</span>;
      String type = searchGuitar.getType().toLowerCase();
      <span class="hljs-keyword">if</span> ((type != <span class="hljs-keyword">null</span>) &amp;&amp; (!searchGuitar.equals(<span class="hljs-string">""</span>)) &amp;&amp;
          (!type.equals(guitar.getType().toLowerCase())))
        <span class="hljs-keyword">continue</span>;
      String backWood = searchGuitar.getBackWood().toLowerCase();
      <span class="hljs-keyword">if</span> ((backWood != <span class="hljs-keyword">null</span>) &amp;&amp; (!backWood.equals(<span class="hljs-string">""</span>)) &amp;&amp;
          (!backWood.equals(guitar.getBackWood().toLowerCase())))
        <span class="hljs-keyword">continue</span>;
      String topWood = searchGuitar.getTopWood().toLowerCase();
      <span class="hljs-keyword">if</span> ((topWood != <span class="hljs-keyword">null</span>) &amp;&amp; (!topWood.equals(<span class="hljs-string">""</span>)) &amp;&amp;
          (!topWood.equals(guitar.getTopWood().toLowerCase())))
        <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">return</span> guitar;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  }
}
</div></code></pre>
<h2 id="algunos-problemas">Algunos problemas</h2>
<ul>
<li>
<p>Se compara el fabricante sin tener en cuenta mayúsculas/minúsculas</p>
</li>
<li>
<p>Se comparan todos los campos sin tener en cuenta
mayúsculas/minúsculas</p>
</li>
<li>
<p>No hay definidas constantes para cada fabricante</p>
</li>
</ul>
<p>¿Estas soluciones abordan el verdadero problema?</p>
<p>Preguntar a Paco...</p>
<h3 id="preguntar-al-cliente">Preguntar al cliente</h3>
<p>Preguntemos a Paco, que no tiene por qué saber nada de objetos ni bases
de datos:</p>
<ul>
<li>
<p>¿Sólo vendes guitarras?</p>
</li>
<li>
<p>¿Cómo actualizas el inventario?</p>
</li>
<li>
<p>¿Cómo funciona la búsqueda de guitarras?</p>
</li>
<li>
<p>¿Necesitarás informes de inventario y de ventas?</p>
</li>
</ul>
<h3 id="respuestas-del-cliente">Respuestas del cliente</h3>
<p>Paco dice que:</p>
<ul>
<li>
<p>Los clientes no siempre conocen las características exactas de la guitarra que quieren</p>
</li>
<li>
<p>Los clientes suelen buscar guitarras dentro de un rango de precios</p>
</li>
<li>
<p>Suele haber más de una guitarra que casa con las necesidades del cliente</p>
</li>
<li>
<p>Sí, necesito informes y demás, pero ¡la prioridad nº 1 es encontrar las guitarras!</p>
</li>
</ul>
<h2 id="ejercicio">Ejercicio</h2>
<p>Hacer refactoring de la aplicación heredada de Guitarras Paco</p>
<h1 id="caso-pr%C3%A1ctico-5">CASO PRÁCTICO 5</h1>
<p><a id="figuras"></a></p>
<h2 id="figuras-geom%C3%A9tricas">Figuras geométricas</h2>
<p><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">Uncle Bob Martin principles</a></p>
<h2 id="span-stylecolorblueprincipio-de-responsabilidad-%C3%BAnica-span"><span style="color:blue;">Principio de responsabilidad única </span></h2>
<p><strong>SRP: <em>Single responsibility Principle</em></strong></p>
<blockquote>
<p>A class should have onlye one reason to change
<cite>-- Uncle Bob Martin</cite></p>
</blockquote>
<ul>
<li>Una clase que modela múltiples aspectos genera acoplamiento entre los distintos aspectos</li>
<li>Un cambio en algún aspecto obligará a cambios accidentales en los clientes que no dependen de dicho aspecto</li>
</ul>
<!-- Los módulos enmarañados que nunca cambian no son problemáticos-->
<p>SRP es lo mismo que el principio de <strong>cohesión</strong> de <a href="bibliografia.html#demarco">DeMarco</a></p>
<h3 id="ejemplo-shapes-v1-en-java">Ejemplo: Shapes v1 en Java</h3>
<p><a id="shapesV1"></a></p>
<ul>
<li>¿Cuántas responsabilidades tienen las clases que implementan la interfaz <code>Shape</code>?</li>
<li>¿Cuáles son estas responsabilidades?</li>
<li>¿Qué parte no cumple SRP en el ejemplo?</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> shapes;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polygon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-function">Point <span class="hljs-title">getVertex</span><span class="hljs-params">(index i)</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Polygon</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectParallelogram</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Polygon</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RectParallelogram</span> </span>{...}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RectParallelogram</span> </span>{...}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClosedCurve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>{...}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClosedCurve</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getCenter</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ellipse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClosedCurve</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getApogeeRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getPerigeeRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getFocus1</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getFocus2</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getCenter</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}
</div></code></pre>
<ul>
<li>Dos responsabilidades: geometría computacional + dibujo en pantalla</li>
<li>Todas las figuras tienen métodos <code>draw</code> y <code>toString</code> (dibujar en pantalla) además del método <code>area</code> que calcula el área (geometría computacional) $\rightarrow$ Violación del SRP</li>
</ul>
<h4 id="soluci%C3%B3n">Solución</h4>
<p>Patrones de diseño: <em>visitor</em></p>
<h4 id="otros-ejemplos">Otros ejemplos</h4>
<ul>
<li>ActiveRecord viola SRP. Sustituir por DAO</li>
</ul>
<h2 id="span-stylecolorblueprincipio-de-abierto-cerradospan"><span style="color:blue;">Principio de Abierto-Cerrado</span></h2>
<p><strong>OCP: <em>Open-Closed Principle</em></strong></p>
<blockquote>
<p>Toda clase, módulo, aspecto o función debe quedar abierto para extensiones pero cerrado para modificaciones</p>
<p><cite>B. Meyer, <a href="#meyer">Object Oriented Software Construction</a></cite></p>
</blockquote>
<ul>
<li>Si un cambio en un sitio origina una cascada de cambios en otros puntos del sistema, el resultado es un sistema frágil y rígido</li>
<li>Es difícil averiguar todos los puntos que requieren cambios</li>
<li>Código cerrado para modificaciones, pero abierto para extensión mediante delegación en vertical (subclases) u horizontal (composición)</li>
</ul>
<h3 id="ejemplo-shapes-versi%C3%B3n-2-en-c">Ejemplo: Shapes versión 2 en C++</h3>
<p>¿Qué parte no cumple OCP en el ejemplo?</p>
<h4 id="versi%C3%B3n-imperativa-sin-objetos">Versión imperativa (sin objetos):</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> ShapeType {circle, square};
<span class="hljs-keyword">struct</span> Shape
{
  ShapeType itsType;
};

<span class="hljs-keyword">struct</span> Circle
{
  ShapeType itsType;
  <span class="hljs-keyword">double</span> itsRadius;
  Point itsCenter;
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawCircle</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> Circle*</span>)</span>;

<span class="hljs-keyword">struct</span> Square
{
  ShapeType itsType;
  <span class="hljs-keyword">double</span> itsSide;
  Point itsTopLeft;
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSquare</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> Square*</span>)</span>;

typedef <span class="hljs-keyword">struct</span> Shape *ShapePointer;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawAllShapes</span>(<span class="hljs-params">ShapePointer list[], <span class="hljs-keyword">int</span> n</span>)
</span>{
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n; i++)
  {
    <span class="hljs-keyword">struct</span> Shape* s = list[i];
    <span class="hljs-keyword">switch</span> (s-&gt;itsType)
    {
      <span class="hljs-keyword">case</span> square:
        DrawSquare((<span class="hljs-keyword">struct</span> Square*)s);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> circle:
        DrawCircle((<span class="hljs-keyword">struct</span> Circle*)s);
        <span class="hljs-keyword">break</span>;
    }
  }
}
</div></code></pre>
<ul>
<li><code>DrawAllShapes</code> no está cerrado para modificaciones cuando aparecen nuevos tipos de <code>Shape</code></li>
</ul>
<h4 id="soluci%C3%B3n">Solución</h4>
<ul>
<li><strong>Abstracción</strong> (ocultación de la implementación): clase abstracta y métodos polimórficos.</li>
<li><strong>Patrones de diseño</strong>: <em>template method</em> y/o <em>strategy</em></li>
</ul>
<p>Aplicando el OCP...</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span>
{
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>: <span class="hljs-title">Shape</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"></span>)
  </span>{
    <span class="hljs-comment">//draw a square</span>
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"></span>)
  </span>{
    <span class="hljs-comment">//draw a circle</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawAllShapes</span>(<span class="hljs-params">IList shapes</span>)
</span>{
  <span class="hljs-keyword">foreach</span>(Shape shape <span class="hljs-keyword">in</span> shapes)
    shape.Draw();
}
</div></code></pre>
<ul>
<li>Si queremos ampliar el comportamiento de <code>DrawAllShapes</code>, solo tenemos que añadir una nueva clase derivada de <code>Shape</code></li>
<li>Si se aplica bien OCP, los cambios de un cierto tipo obligan a añadir nuevo código, no a modificar el existente</li>
</ul>
<blockquote>
<p>In general, no matter how <em>closed</em> a module is, there will always be some kind of change against which it is not closed. There is no model that is natural to all contexts!</p>
<p>Since closure cannot be complete, it must be strategic. That is, the designer must choose the kinds of changes against which to close the design, must guess at the kinds of changes that are most likely, and then construct abstractions to protect against those changes.</p>
<p><cite>-- Bob C. Martin</cite></p>
</blockquote>
<h2 id="span-stylecolorblueprincipo-de-segregaci%C3%B3n-de-interfacesspan"><span style="color:blue;">Principo de segregación de interfaces</span></h2>
<p><strong>ISP: <em>Interface Segregation Principle</em></strong></p>
<blockquote>
<p>Los clientes no deben depender de métodos que no usan.</p>
<p><cite>Bob C. Martin</cite></p>
</blockquote>
<ul>
<li>Las interfaces son para los <strong>clientes</strong>, no para hacer jerarquías</li>
<li>Evitar interfaces <strong>gruesas</strong> con muchos métodos (descohesionadas)</li>
<li>Los cambios en los métodos ignorados pueden provocar cambios en un cliente que no los usa</li>
<li>La interfaz de una clase puede dividirse en <strong>bloques</strong> de métodos relacionados. Unos clientes usan un bloque y otros clientes usan otro bloque. Si un cliente necesita conocer una interfaz no cohesionada, debe hacerlo combinando una o más clases (sus interfaces)</li>
<li>ISP es a las interfaces lo que SRP es a clases y métodos</li>
<li>Violar el ISP es muy común en lenguajes de tipos estáticos (C++, Java, C#). Los lenguajes dinámicos (Ruby, Scala) ayudan algo más a no violar el ISP (v.g. con los <em>mixins</em>)</li>
</ul>
<h3 id="ejemplo-acoplamiento-contexto-strategy">Ejemplo: acoplamiento contexto-strategy</h3>
<ul>
<li>¿Cómo se comunican <em>Strategy</em> y <em>Context</em> (acoplado/desacoplado)?</li>
<li><em>Context</em> Puede definir una interfaz que le permita a <em>Strategy</em> acceder a sus datos</li>
</ul>
<h3 id="ejemplo-puertas-de-seguridad">Ejemplo: puertas de seguridad</h3>
<p>Una implementación de puertas de seguridad con temporizador (<code>TimedDoor</code>) que hace sonar una alarma cuando la puerta está abierta durante un cierto tiempo.</p>
<h4 id="dise%C3%B1o">Diseño</h4>
<ul>
<li>
<p><code>TimedDoor</code> se comunica con <code>Timer</code> para registrar un temporizador</p>
</li>
<li>
<p>Cuando salta el temporizador, avisa a un <code>TimerClient</code></p>
</li>
<li>
<p>Con la siguiente solución, un <code>TimerClient</code> puede registrarse a sí mismo en un <code>Timer</code> y recibir un mensaje <code>Timeout()</code>.</p>
<p><img src="./figuras/isp-timer-door.png" alt="Puertas de seguridad"></p>
</li>
</ul>
<h4 id="implementaci%C3%B3n-inicial">Implementación inicial</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Register</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> timeout, TimerClient client</span>) </span>{
    <span class="hljs-comment">/*code*/</span> 
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">TimerClient</span> {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TimeOut</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<ul>
<li>Si se cierra la puerta antes de que venza el timeout $t_0$ y se vuelve a abrir, se registra uno nuevo $t_1$ antes de que el antiguo haya expirado.</li>
<li>Cuando el primer temporizador $t_0$ expira, se produce la llamada a <code>Timeout()</code> de <code>TimedDoor</code> y no debería.</li>
<li>Así que cambiamos la implementación:</li>
</ul>
<h4 id="implementaci%C3%B3n-mejorada">Implementación mejorada</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Register</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> timeout, <span class="hljs-keyword">int</span> timeOutId, TimerClient client</span>) </span>{
    <span class="hljs-comment">/*code*/</span>
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">TimerClient</span> {
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TimeOut</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> timeOutID</span>)</span>;
}
</div></code></pre>
<p>¿En qué ha afectado el <strong>cambio en la implementación</strong> de <code>TimerClient</code>?</p>
<ul>
<li>El cambio afecta a los usuarios de <code>TimerClient</code>, pero también a <code>Door</code> y a los clientes de <code>Door</code> (y no debería)</li>
<li>El problema es que <code>Door</code> depende de <code>TimerClient</code> y no todas las variedades de puerta son de seguridad (con temporizador)</li>
<li>Si hacen falta más variedades de puerta, todas ellas deberán implementar implementaciones degeneradas de <code>Timeout</code></li>
<li>Las interfaces empiezan a engrosarse. Esto puede acabar violando también el LSP</li>
</ul>
<h4 id="redise%C3%B1o-puertas-de-seguridad">Rediseño: puertas de seguridad</h4>
<p><strong>Delegación</strong> a través del patrón adapter (de objetos o de clases)</p>
<ul>
<li>
<p>Versión adaptador de clases (por herencia):</p>
<p><img src="./figuras/isp-timer-door-class-adapter.png" alt="Puertas de seguridad - adaptador de clases"></p>
</li>
<li>
<p>Versión adaptador de objetos (por composición):</p>
<p><img src="./figuras/isp-timer-door-object-adapter.png" alt="Puertas de seguridad - adaptador de objetos"></p>
</li>
</ul>
<h2 id="aplicaci%C3%B3n-de-ocp-y-srp">Aplicación de OCP y SRP</h2>
<h3 id="ejemplo-shapes-versi%C3%B3n-1">Ejemplo: <a href="#shapesV1">Shapes versión 1</a></h3>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> shapes;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polygon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-function">Point <span class="hljs-title">getVertex</span><span class="hljs-params">(index i)</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Polygon</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectParallelogram</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Polygon</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RectParallelogram</span> </span>{...}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RectParallelogram</span> </span>{...}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClosedCurve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>{...}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
    <span class="hljs-keyword">extends</span> <span class="hljs-title">ClosedCurve</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getCenter</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ellipse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClosedCurve</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getApogeeRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getPerigeeRadius</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getFocus1</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getFocus2</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">Point <span class="hljs-title">getCenter</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{...}
  <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{...}
}
</div></code></pre>
<ul>
<li>Las funcionalidades para pintar (<code>draw</code>) y para imprimir (<code>toString</code>) pueden descohesionar las clases y atentar contra OCP y SRP.</li>
<li>Saquémoslas fuera utilizando <strong>aspectos</strong>:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Ficheros &lt;X&gt;ToString.aj (uno por aspecto)</span>
<span class="hljs-keyword">package</span> shapes.tostring; <span class="hljs-comment">// para todos los toString()</span>
aspect PolygonToString {
  String Polygon.toString() {
    StringBuffer buff = <span class="hljs-keyword">new</span> StringBuffer();
    buff.append(getClass().getName());
     <span class="hljs-comment">//... añadir nombre y área...</span>
     <span class="hljs-comment">//... añadir cada línea desde un vértice al siguiente</span>
    <span class="hljs-keyword">return</span> buff.toString();
  }
}
aspect CircleToString {
  String Circle.toString() {...}
}
aspect EllipseToString {
  String Ellipse.toString() {...}
}

<span class="hljs-comment">// Drawable.java</span>
<span class="hljs-keyword">package</span> drawing;
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Drawable</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-comment">// Ficheros Drawable&lt;X&gt;.aj</span>
<span class="hljs-keyword">package</span> shapes.drawing; <span class="hljs-comment">// para todos los draw()...</span>
<span class="hljs-keyword">import</span> drawing.Drawable;
<span class="hljs-keyword">abstract</span> aspect DrawableShape {
  declare parents: Shape implements Drawable;
  <span class="hljs-keyword">void</span> Shape.draw () <span class="hljs-comment">//template method</span>
  {
    String drawCommand = makeDrawCommand();
    <span class="hljs-comment">// enviar orden al motor gráfico...</span>
  }
  String Shape.makeDrawCommand() {
    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">"\n"</span> + makeDetails(<span class="hljs-string">"\t"</span>);
  }
  <span class="hljs-keyword">abstract</span> String Shape.makeDetails (String indent);
}
aspect DrawablePolygon extends DrawableShape {
  String Polygon.makeDetails (String indent){...}
}
aspect DrawableCircle extends DrawableShape {
  String Circle.makeDetails (String indent){...}
}
aspect DrawableEllipse extends DrawableShape {
  String Ellipse. makeDetails (String indent){...} }
</div></code></pre>
<h2 id="span-stylecolorblueprincipio-de-sustituci%C3%B3n-de-liskovspan"><span style="color:blue;">Principio de sustitución de Liskov</span></h2>
<p><strong>LSP: <em>Liskov Substitution Principle</em></strong></p>
<blockquote>
<p>Un subtipo debe poder ser sustituible por sus tipos base</p>
<p><cite>Barbara Liskov, </cite></p>
</blockquote>
<p>Si una función $f$ depende de una clase base $B$ y hay una $D$ derivada de $B$, las instancias de $D$ no deben alterar el comportamiento definido por $B$ de modo que $f$ deje de funcionar</p>
<!--
-   Posibilidad de sustitución depende del contexto: En otro programa
    P2, los objetos D pueden no ser sustituibles por objetos B
-->
<h3 id="ejemplo-shapes-versi%C3%B3n-3">Ejemplo: Shapes versión 3</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> Point {<span class="hljs-keyword">double</span> x, y;}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ShapeType {square, circle};

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> {
  <span class="hljs-keyword">private</span> ShapeType type;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span>(<span class="hljs-params">ShapeType t</span>)</span>{type = t;}
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span>(<span class="hljs-params">Shape s</span>) </span>{
    <span class="hljs-keyword">if</span>(s.type == ShapeType.square)
      (s <span class="hljs-keyword">as</span> Square).Draw();
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.type == ShapeType.circle)
      (s <span class="hljs-keyword">as</span> Circle).Draw();
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">Shape</span> {
  <span class="hljs-keyword">private</span> Point center;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"></span>): <span class="hljs-title">base</span>(<span class="hljs-params">ShapeType.circle</span>) </span>{}
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-comment">/* draws the circle */</span>}
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>: <span class="hljs-title">Shape</span> {
  <span class="hljs-keyword">private</span> Point topLeft;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> side;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span>(<span class="hljs-params"></span>): <span class="hljs-title">base</span>(<span class="hljs-params">ShapeType.square</span>) </span>{}
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-comment">/* draws the square */</span>}
}
</div></code></pre>
<ul>
<li>
<p><code>DrawShape</code> viola claramente el OCP</p>
</li>
<li>
<p>Además <code>Square</code> y <code>Circle</code> no son sustuibles por <code>Shape</code>: no redefinen ninguna función de <code>Shape</code>, sino que añaden <code>Draw()</code> (violación del LSP)</p>
</li>
<li>
<p>Esta violación de LSP es la que provoca la violación de OCP en <code>DrawShape</code></p>
</li>
<li>
<p>Violación más sutil de LSP...</p>
</li>
</ul>
<h3 id="ejemplo-rect%C3%A1ngulos-versi%C3%B3n-1">Ejemplo: rectángulos versión 1</h3>
<p>De momento solo necesitamos rectángulos y escribimos esta versión:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> {
  <span class="hljs-keyword">private</span> Point topLeft;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> height;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Width {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> width; }
    <span class="hljs-keyword">set</span> { width = <span class="hljs-keyword">value</span>; }
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Height {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> height; }
    <span class="hljs-keyword">set</span> { height = <span class="hljs-keyword">value</span>; }
  }
}
</div></code></pre>
<p>Un día hace falta manejar cuadrados además de rectángulos.</p>
<p>Geométricamente, un cuadrado es un rectángulo, así que hacemos uso de la herencia (relación <strong>es-un</strong>):</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>: <span class="hljs-title">Rectangle</span> </span>{
   ...
}
</div></code></pre>
<h4 id="problema-cuadrados-como-rect%C3%A1ngulos">Problema: cuadrados como rectángulos</h4>
<ul>
<li>
<p>Un cuadrado podría ser un rectángulo, pero definitivamente un objeto <code>Square</code> <strong>no es un</strong> objeto <code>Rectangle</code></p>
</li>
<li>
<p>Un <code>Square</code> no tiene propiedades <code>height</code>y <code>width</code>. Pero supongamos que no nos importa el desperdicio de memoria.</p>
</li>
<li>
<p><code>Square</code> heredará los métodos accesores de <code>Rectangle</code>.</p>
</li>
<li>
<p>Así que hacemos lo siguiente...</p>
</li>
</ul>
<h3 id="ejemplo-rect%C3%A1ngulos-versi%C3%B3n-2">Ejemplo: rectángulos versión 2</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>: <span class="hljs-title">Rectangle</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span> Width
  {
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">value</span>;
      <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span> Height
  {
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;
      <span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">value</span>;
    }
  }
}
</div></code></pre>
<ul>
<li>
<p>El comportamiento de un objeto <code>Square</code> no es consistente con el de un objeto <code>Rectangle</code>:</p>
<pre class="hljs"><code><div>Square s = <span class="hljs-keyword">new</span> Square();
s.SetWidth(<span class="hljs-number">1</span>);   <span class="hljs-comment">// fija ambos</span>
s.SetHeight(<span class="hljs-number">2</span>);  <span class="hljs-comment">// fija ambos</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params">Rectangle r</span>)
</span>{
  r.SetWidth(<span class="hljs-number">32</span>); <span class="hljs-comment">// calls Rectangle.SetWidth</span>
}
</div></code></pre>
</li>
<li>
<p>¿Qué sucede si pasamos un <code>Square</code> a la función <code>f</code>?</p>
<p>¡No cambia <code>Height</code>!</p>
</li>
<li>
<p>Podría argumentarse que el error era que los métodos <code>Width</code>y <code>Height</code> no se declararon <code>virtual</code> en <code>Rectangle</code>.</p>
</li>
</ul>
<h4 id="extensi%C3%B3n-y-ocultaci%C3%B3n-de-m%C3%A9todos">Extensión y ocultación de métodos</h4>
<ul>
<li>La <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords">diferencia entre <code>new</code> y <code>override</code> en un método en C#</a> es que <code>new</code> oculta la implementación de la clase base y <code>override</code> la extiende.</li>
</ul>
<p>Sin embargo, cuando la creación de una clase derivada provoca cambios en la clase base, es síntoma de un <strong>mal diseño</strong>.</p>
<p>El LSP pone en evidencia que la relación <strong>es-un</strong> tiene que ver con el comportamiento público extrínseco, del que los clientes dependen.</p>
<h3 id="ejemplo-rect%C3%A1ngulos-versi%C3%B3n-3">Ejemplo: rectángulos versión 3</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>
{
  <span class="hljs-keyword">private</span> Point topLeft;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> height;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> Width
  {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> width; }
    <span class="hljs-keyword">set</span> { width = <span class="hljs-keyword">value</span>; }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> Height
  {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> height; }
    <span class="hljs-keyword">set</span> { height = <span class="hljs-keyword">value</span>; }
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>: <span class="hljs-title">Rectangle</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">double</span> Width
  {
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">value</span>;
      <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">double</span> Height
  {
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">base</span>.Height = <span class="hljs-keyword">value</span>;
      <span class="hljs-keyword">base</span>.Width = <span class="hljs-keyword">value</span>;
    }
  }
}
</div></code></pre>
<p>Ahora parece que funcionan <code>Square</code> y <code>Rectangle</code>, que matemáticamente quedan bien definidos.</p>
<p>Pero consideremos esto:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span>(<span class="hljs-params">Rectangle r</span>)
</span>{
  r.Width = <span class="hljs-number">5</span>;    <span class="hljs-comment">// cree que es un Rectangle</span>
  r.Height = <span class="hljs-number">4</span>;   <span class="hljs-comment">// cree que es un Rectangle</span>
  <span class="hljs-keyword">if</span>(r.Area() != <span class="hljs-number">20</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Bad area!"</span>);
}
</div></code></pre>
<p>¿Qué pasa si llamamos a <code>g(new Square(3))</code>?</p>
<p>El autor de <code>g</code> asumió que cambiar el ancho de un rectángulo deja intacto el alto. Si pasamos un cuadrado esto no es así</p>
<p><strong>Violación de LSP</strong>: Si pasamos una instancia de una clase derivada (<code>Square</code>), se altera el comportamiento definido por la clase base (<code>Rectangle</code>) de forma que <code>g</code> deja de funcionar.</p>
<p>¿Quién tiene la culpa?</p>
<ul>
<li>¿El autor de <code>g</code> por asumir que &quot;en un rectángulo su ancho y alto son independientes&quot; (<em>invariante</em>)?</li>
<li>¿El autor de <code>Square</code> por violar el invariante?</li>
<li>¿De qué clase se ha violado el invariante? ¡De <code>Rectangle</code> y no de <code>Square</code>!</li>
</ul>
<p>Para evaluar si un diseño es apropiado, no se debe tener en cuenta la solución por sí sola, sino en términos de los <em>supuestos razonables</em> que hagan los usuarios del diseño.</p>
<h3 id="ejercicios-de-lsp">Ejercicios de LSP</h3>
<ul>
<li>Robert C. Martin &amp; Micah Martin: <a href="#unclebob">Agile Principles, Patterns and Practices in C#</a>, Prentice Hall, 2006</li>
</ul>
<h3 id="span-stylecolorbluedise%C3%B1o-por-contratospan"><span style="color:blue;">Diseño por Contrato</span></h3>
<p>Relación entre LSP y el <strong><em>Design-By-Contract</em></strong> (DBC) de <em>Bertrand
Meyer</em>:</p>
<blockquote>
<p>A routine redeclaration [in a derivative] may only replace the original precondition by one equal or weaker, and the original post-condition by one equal or stronger</p>
<p>–– <cite>B. Meyer</cite></p>
</blockquote>
<ul>
<li>Métodos de clase declaran <em>precondiciones</em> y <em>postcondiciones</em> al redefinir una operación en una subclase derivada
<ul>
<li>las <strong>precondiciones</strong> sólo pueden sustituirse por otras más débiles/laxas</li>
<li>las <strong>postcondiciones</strong> sólo pueden sustituirse por otras más fuertes/estrictas</li>
</ul>
</li>
</ul>
<h4 id="ejemplo-rect%C3%A1ngulos">Ejemplo: rectángulos</h4>
<ul>
<li>
<p>Postcondición del <em>setter</em> de <code>Rectangle.Width</code>
(En C++ sería <code>Rectangle::SetWidth(double w)</code>):
<code>assert((Width == w) &amp;&amp; (Height == old.Height));</code></p>
</li>
<li>
<p>Postcondición del setter de <code>Square.Witdh</code>
En C++ sería <code>Square::SetWidth(double w)</code>):
<code>assert(Width==w);</code></p>
</li>
<li>
<p>La postcondición de <code>Square::SetWidth(double w)</code> viola el  contrato de la clase base porque es más débil que la de <code>Rectangle</code></p>
</li>
</ul>
<h2 id="span-stylecolorblueprincipio-de-inversi%C3%B3n-de-dependenciasspan"><span style="color:blue;">Principio de Inversión de Dependencias</span></h2>
<p><strong>DIP: <em>Dependency Inversion Principle</em></strong></p>
<ul>
<li>
<p>Los módulos de alto nivel no deben depender de módulos de bajo nivel.
Ambos deben depender de abstracciones.</p>
</li>
<li>
<p>Las abstracciones no deben depender de los detalles, sino los detalles de las abstracciones</p>
</li>
</ul>
<blockquote>
<p>Depend on abstractions</p>
<p><cite>Robert C. Martin</cite></p>
</blockquote>
<p>###Ejemplo: estructura en capas</p>
<p><strong>Diseño inicial</strong>:</p>
<p><img src="./figuras/dip-1.png" alt="estructura en capas"></p>
<ul>
<li>Las dependencias son transitivas</li>
<li><em>Policy</em> depende de todo lo que depende <em>Mechanism</em>.</li>
</ul>
<p><strong>Diseño invertido</strong>:</p>
<p><img src="./figuras/dip-2.png" alt="capas invertidas"></p>
<ul>
<li>Cada nivel declara una interfaz para lo que necesita de otros niveles inferiores</li>
<li>Los niveles inferiores dependen de interfaces definidas en los superiores</li>
<li>El cliente puede definir la abstracción que necesita (ISP)</li>
<li>Cada nivel es intercambiable por un sustituto</li>
</ul>
<h3 id="span-stylecolorblueheur%C3%ADstica-ingenuaspan"><span style="color:blue;">Heurística <em>ingenua</em></span>:</h3>
<ul>
<li>Ninguna variable debería guardar una referencia a una clase concreta</li>
<li>Ninguna clase debería ser derivada de una clase concreta</li>
<li>Ningún método debería redefinir un método ya implementado de ninguna de sus clases base</li>
</ul>
<p>Hay que violar alguna vez estas heurísticas, pues alguien tiene que crear las instancias de las clases concretas. El módulo que lo haga presentará una dependencia de dichas clases concretas.</p>
<p>Gracias a la introspección o la carga dinámica de clases, los lenguajes de programación pueden indicar el nombre de la clase a instanciar (por ejemplo, en un fichero de configuración).</p>
<p>Hay clases concretas que no cambian, como <code>string</code>, así que no hace ningún daño depender de ellas.</p>

</body>
</html>
